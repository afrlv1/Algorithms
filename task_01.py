def solution(head, index):
    t = head
    if index == 0:
        t.next_item = None
        return t
    while index-1:
        head = head.next_item
        index -= 1
    tmp = head.next_item
    head.next_item = new_node
    new_node.next_item = tmp
    return t

"""
На вход она принимает голову списка, индекс, по которому вы хотите добавить элемент, и значение нового элемента. Возвращать функция будет голову списка.
Запомним голову списка в переменной head, чтобы потом вернуть её из функции. Сначала создадим объект класса Node из добавляемого элемента, так как все элементы в списке должны иметь два поля: значение и ссылку на соседа. Это нам и обеспечит класс Node.
Как вы, вероятно, догадались, нужно найти элемент, за которым хотим вставить новый, и переместить его указатель на вставляемый элемент. Новый элемент должен указывать на прошлого соседа того элемента, после которого мы сделали вставку.
Отдельно нужно обработать случай, когда хотим вставить элемент в голову списка, так как на неё никакой элемент не указывает. Добавляем новый элемент в качестве головы списка. Он будет ссылаться на предыдущую голову.
На первой итерации цикла переменная index-1 будет равна 1, и мы переместимся вправо на элемент с индексом 1. После этого элемента мы и хотим добавить новый. На второй итерации переменная index-1 будет равна 0, блок кода внутри цикла выполняться не будет. Как раз это нам и нужно, так как до нужной позиции мы уже дошли. Затем меняем указатели. Элемент, на который указывал найденный объект, запомним во временную переменную. Это нужно сделать, потому что мы переставим указывающую на него ссылку. А терять этот элемент нельзя, ведь на него будет указывать вставляемый элемент. Поменяв ссылки, можем вернуть голову списка из функции.
"""

